---
title: 'systemd socket'
date: 2020-09-15 14:32:42 +0800
categories: [Tools, systemd]
tags: [systemd]
published: true
img_path: /assets/img/postimgs/Tools/systemd/
---


可以让 systemd 监听套接字，在有连接时再启动服务，systemd中**主要是使用本地socket(AF_UNIX)**，网络socket也支持（AF_INET），
这是从inetd学习过来的，主要特点是增加并行性(套接字激活允许同时启动套接字的客户端和服务器)、
简单性(因为不需要配置服务之间的显式依赖关系)和健壮性(因为服务可以重新启动或可能崩溃，而不会失去套接字的连通性)。

socket激活大致表述就是systemd会启动一个socket，当这个socket有流量过来时，systemd就启动对应的service服务。
具体参考 `man systemd.socket`

使用套接字激活的三种方案

（1）使用套接字激活以达到简单，并行和健壮的的目的：套接字在早期引导期间被绑定，并且在引导时立即启动一个服务所有客户端请求的单例服务实例。
这对于所有可能频繁和连续使用的服务都很有用，因此建议尽早启动它们并与系统的其他部分并行。例如:D-Bus、Syslog。

（2）单例服务的按需套接字激活:套接字在早期引导期间绑定，并且在有流量出入时执行单例服务实例。这对于很少使用的服务非常有用，建议在引导时节省资源和时间，
并推迟激活，直到实际需要时再激活。例如:CUPS。

（3）针对每个连接的服务实例的按需套接字激活:套接字在早期引导期间绑定，对于每个传入的连接，将实例化一个新的服务实例，并将连接套接字(而不是侦听的套接字)
传递给它。这对于很少使用的服务，以及性能不重要的服务非常有用，例如，为每个传入连接生成新服务进程的成本是有限的。例子:SSH。(ssh可以使用socket激活，也
可以直接作为一个service常态运行)

这三种方案提供了不同的性能特征。在服务启动完成后，前两种方案提供的性能与普通独立服务相同，因为侦听套接字被传递给实际的服务，从那时起代码路径与独立服务相同，
所有连接的处理方式与独立服务完全相同。第三种方案的性能通常没有那么好:因为每个连接都需要启动一个新的服务，资源成本要高得多。但也有许多优点，
例如，客户端连接可以更好地隔离，并且更容易开发以这种方式激活的服务。






